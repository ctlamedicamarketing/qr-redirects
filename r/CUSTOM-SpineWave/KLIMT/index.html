<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>KLIMT • Video + PDF Downloads</title>
<meta name="robots" content="noindex, nofollow" />
<style>
  :root{
    --bg:#0b0c10; --panel:#0d111a; --ink:#e8eaed; --muted:#9aa0a6;
    --stroke:#1e2330; --accent:#ffc81a;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);
            font:15px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial}
  a{color:var(--ink)}
  .wrap{min-height:100%;display:grid;grid-template-rows:auto 1fr auto;gap:16px;max-width:1200px;margin:0 auto;padding:16px}
  header.app{display:flex;gap:10px;align-items:center;justify-content:space-between;padding-bottom:8px;border-bottom:1px solid var(--stroke)}
  header.app h1{margin:0;font-size:18px;font-weight:700;letter-spacing:.02em}
  .btn{appearance:none;border:1px solid var(--stroke);background:linear-gradient(180deg,#0f1320,#0b0f1b);
       color:var(--ink);padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:600;text-decoration:none}
  .btn:hover{border-color:var(--accent)}
  .grid{display:grid;grid-template-columns:1fr 1.4fr;gap:16px}
  @media (max-width:980px){.grid{grid-template-columns:1fr}}
  .card{background:var(--panel);border:1px solid var(--stroke);border-radius:14px;overflow:hidden;display:flex;flex-direction:column}
  .card .head{display:flex;align-items:center;gap:10px;justify-content:space-between;padding:12px;border-bottom:1px solid var(--stroke)}
  .card .head h2{margin:0;font-size:14px;font-weight:700}
  .frame{position:relative;aspect-ratio:16/9;width:100%;background:#000}
  .frame > iframe{position:absolute;inset:0;width:100%;height:100%;border:0}
  .list{padding:12px; display:grid; gap:12px}
  .item{display:flex;align-items:center;gap:12px;flex-wrap:wrap;border:1px solid var(--stroke);border-radius:12px;padding:10px}
  .item h3{margin:0;font-size:14px}
  .muted{color:var(--muted)}
  details.debug{padding:8px 12px;border-top:1px dashed var(--stroke);font-size:12px;color:var(--muted)}
  footer{display:flex;justify-content:flex-end;gap:10px;align-items:center;padding-top:8px;border-top:1px solid var(--stroke)}
</style>
</head>
<body>
<div class="wrap">

  <!-- Top -->
  <header class="app">
    <h1>KLIMT — Video & PDF Downloads</h1>
  </header>

  <!-- Main -->
  <div class="grid">

    <!-- Left: YouTube -->
    <section class="card" aria-label="Video">
      <div class="head"><h2>Product Teaser</h2></div>
      <div class="frame">
        <iframe id="yt" title="YouTube video" allow="autoplay; encrypted-media; picture-in-picture; web-share"
                allowfullscreen loading="lazy" referrerpolicy="strict-origin-when-cross-origin"></iframe>
      </div>
    </section>

    <!-- Right: PDFs (Download only) -->
    <section class="card" aria-label="Documents">
      <div class="head">
        <h2>Documents</h2>
      </div>

      <div id="docList" class="list" aria-live="polite"></div>

      <details class="debug" id="debug">
        <summary>Debug</summary>
        <div id="debugBody">Ready.</div>
      </details>
    </section>
  </div>

  <!-- Bottom -->
  <footer>
    <div class="muted">Downloads verify real PDFs and try Local → Pages → Raw.</div>
  </footer>
</div>

<script>
  /* ========================== CONFIG — EDIT THESE ==========================
   * 1) YOUTUBE: replace with the 11-char ID from your video URL.
   * 2) DOCS: filenames/paths are case-sensitive. Local assumes this HTML
   *    lives beside the PDFs in /qr-redirects/r/CUSTOM-SpineWave/KLIMT/.
   * ======================================================================= */

  const YT_ID = "cLHOGWiA6YQ";

  const DOCS = [
    {
      label: "KLIMT Overview",
      filename: "KLIMT-Overview.pdf",
      paths: {
        local: "./KLIMT-Overview.pdf",
        pages: "https://ctlamedicamarketing.github.io/qr-redirects/r/CUSTOM-SpineWave/KLIMT/KLIMT-Overview.pdf",
        raw:   "https://raw.githubusercontent.com/ctlamedicamarketing/qr-redirects/main/r/CUSTOM-SpineWave/KLIMT/KLIMT-Overview.pdf"
      }
    },
    {
      label: "KLIMT STG",
      filename: "KLIMT-STG.pdf",
      paths: {
        local: "./KLIMT-STG.pdf",
        pages: "https://ctlamedicamarketing.github.io/qr-redirects/r/CUSTOM-SpineWave/KLIMT/KLIMT-STG.pdf",
        raw:   "https://raw.githubusercontent.com/ctlamedicamarketing/qr-redirects/main/r/CUSTOM-SpineWave/KLIMT/KLIMT-STG.pdf"
      }
    },
    {
      label: "Klimt Expansion Table & Tips",
      filename: "Klimt-Expansion-table-and-Tips.pdf",
      paths: {
        local: "./Klimt-Expansion-table-and-Tips.pdf",
        pages: "https://ctlamedicamarketing.github.io/qr-redirects/r/CUSTOM-SpineWave/KLIMT/Klimt-Expansion-table-and-Tips.pdf",
        raw:   "https://raw.githubusercontent.com/ctlamedicamarketing/qr-redirects/main/r/CUSTOM-SpineWave/KLIMT/Klimt-Expansion-table-and-Tips.pdf"
      }
    },
    {
      label: "Klimt Expansion Table",
      filename: "Klimt-Expansion-table.pdf",
      paths: {
        local: "./Klimt-Expansion-table.pdf",
        pages: "https://ctlamedicamarketing.github.io/qr-redirects/r/CUSTOM-SpineWave/KLIMT/Klimt-Expansion-table.pdf",
        raw:   "https://raw.githubusercontent.com/ctlamedicamarketing/qr-redirects/main/r/CUSTOM-SpineWave/KLIMT/Klimt-Expansion-table.pdf"
      }
    }
  ];

  /* ============================ END CONFIG ============================ */

  // ---------- YouTube ----------
  (function initYouTube(){
    const yt = document.getElementById('yt');
    const origin = location.origin;
    const params = new URLSearchParams({
      autoplay:'0', mute:'1', controls:'1', modestbranding:'1', rel:'0',
      playsinline:'1', loop:'1', playlist:YT_ID, enablejsapi:'1', origin
    });
    yt.src = `https://www.youtube.com/embed/${YT_ID}?` + params.toString();
  })();

  // ---------- Download utilities ----------
  async function tryHead(url) {
    try { const r = await fetch(url, { method:'HEAD', cache:'no-store', mode:'cors' }); return r.ok ? r : null; }
    catch { return null; }
  }

  function withBuster(url) {
    const u = new URL(url, location.href);
    u.searchParams.set('_v', String(Date.now())); // cache-buster to dodge stale/partial responses
    return u.toString();
  }

  // Prefer Local (no HEAD), then Pages, then Raw
  async function resolveUrl(paths){
    if (paths.local) {
      try { return new URL(paths.local, location.href).toString(); }
      catch { return paths.local; }
    }
    if (paths.pages && await tryHead(paths.pages)) return paths.pages;
    if (paths.raw   && await tryHead(paths.raw))   return paths.raw;
    return null;
  }

  // Confirm a real PDF:
  //  - MIME: application/pdf OR
  //  - header starts with %PDF-  AND trailer has %%EOF, size > 1KB
  async function isRealPdf(res, blob) {
    const size = blob.size;
    if (size < 1024) return { ok:false, reason:`too small (${size} bytes)` };

    const ct = (res.headers.get('content-type') || '').toLowerCase();
    const ctLooksPdf = ct.includes('application/pdf');

    const headBuf = await blob.slice(0, 5).arrayBuffer();
    const head = new Uint8Array(headBuf);
    const hasPdfHeader = head[0]===0x25 && head[1]===0x50 && head[2]===0x44 && head[3]===0x46 && head[4]===0x2D; // %PDF-

    const tailSlice = blob.slice(Math.max(0, size - 1024), size);
    const tailText = await tailSlice.text();
    const hasPdfEOF = /%%EOF\s*$/.test(tailText);

    const ok = (ctLooksPdf || hasPdfHeader) && hasPdfEOF;
    return { ok, reason: `ct=${ct || "unknown"}, header=${hasPdfHeader}, eof=${hasPdfEOF}, size=${size}` };
  }

  async function forceDownload(paths, suggestedName, btn){
    const baseUrl = await resolveUrl(paths);
    if (!baseUrl) { alert('No valid download URL found.'); return; }

    const url = withBuster(baseUrl);
    const originalText = btn.textContent;
    btn.textContent = "Downloading…";
    btn.disabled = true;

    try {
      const res = await fetch(url, { mode:'cors', credentials:'omit', cache:'no-store' });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);

      const blob = await res.blob();
      const verdict = await isRealPdf(res, blob);
      if (!verdict.ok) throw new Error(`Not a valid PDF: ${verdict.reason}`);

      const filename = (() => {
        const cd = res.headers.get('content-disposition');
        if (cd) {
          const m = cd.match(/filename\*?=(?:UTF-8''|")?([^\";]+)\"?/i);
          if (m && m[1]) { try { return decodeURIComponent(m[1]); } catch { return m[1]; } }
        }
        try { return new URL(baseUrl).pathname.split('/').pop() || suggestedName; }
        catch { return suggestedName; }
      })();

      const a = document.createElement('a');
      const objectUrl = URL.createObjectURL(blob);
      a.href = objectUrl; a.download = filename;
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(objectUrl);

      btn.textContent = "Downloaded ✓";
      console.info(`[PDF] saved ${filename} from ${baseUrl} (${blob.size} bytes)`);
    } catch (err){
      console.warn('PDF verify/save failed; opening instead:', err);
      window.open(baseUrl, '_blank', 'noopener');   // user can Save As…
      btn.textContent = "Opened in new tab";
    } finally {
      setTimeout(()=>{ btn.textContent = originalText; btn.disabled = false; }, 1800);
    }
  }

  // ---------- Build UI ----------
  const els = { docList: document.getElementById('docList'), debugBody: document.getElementById('debugBody') };

  async function populateDocs(){
    for (const d of DOCS){
      const row = document.createElement('div');
      row.className = 'item';

      const title = document.createElement('h3');
      title.textContent = d.label;

      const download = document.createElement('button');
      download.className = 'btn';
      download.type = 'button';
      download.textContent = 'Download';
      download.addEventListener('click', ()=> forceDownload(d.paths, d.filename, download));

      row.appendChild(title);
      row.appendChild(download);
      els.docList.appendChild(row);

      // Debug: show reachability for each variant
      const variants = [
        ['Local', d.paths.local ? new URL(d.paths.local, location.href).toString() : null],
        ['Pages', d.paths.pages],
        ['Raw',   d.paths.raw]
      ];
      for (const [label, url] of variants){
        if (!url) continue;
        let status = '…';
        try { status = (label === 'Local') ? '—' : ((await tryHead(url)) ? '✅' : '⚠️ (HEAD failed)'); }
        catch { status = '⚠️'; }
        const p = document.createElement('p');
        p.innerHTML = `• <b>${d.label}</b> – ${label}: <a href="${url}" target="_blank" rel="noopener">${url}</a> ${status}`;
        els.debugBody.appendChild(p);
      }
    }
  }

  populateDocs();
</script>
</body>
</html>
