<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Embedded YouTube + Multipage PDFs</title>
<meta name="robots" content="noindex, nofollow" />
<style>
  :root{ --bg:#0b0c10; --ink:#e8eaed; --accent:#ffc81a; --stroke:#1e2330; }
  *{ box-sizing:border-box }
  html,body{ height:100%; margin:0; background:var(--bg); color:var(--ink);
             font:16px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Arial }
  .wrap{ min-height:100%; display:grid; grid-template-rows:auto 1fr; gap:16px; padding:16px; }
  header{ display:flex; gap:12px; align-items:center; justify-content:space-between;
          border-bottom:1px solid var(--stroke); padding-bottom:8px }
  header h1{ font-size:18px; margin:0; font-weight:600 }
  .grid{ display:grid; grid-template-columns:1fr 2fr; gap:16px; }
  @media (max-width:900px){ .grid{ grid-template-columns:1fr; grid-auto-rows:minmax(240px,auto) } }
  .card{ border:1px solid var(--stroke); border-radius:12px; overflow:hidden;
         background:linear-gradient(180deg,#0d1019,#0b0f1b); display:flex; flex-direction:column; }
  .card header{ padding:10px 12px; border-bottom:1px solid var(--stroke);
                display:flex; align-items:center; justify-content:space-between; gap:8px; flex-wrap:wrap; }
  .card header h2{ font-size:14px; margin:0; font-weight:600; letter-spacing:.02em }
  .frame{ position:relative; aspect-ratio:16/9; width:100%; background:#000 }
  .frame > iframe{ position:absolute; inset:0; width:100%; height:100%; border:0 }
  .controls{ display:flex; gap:8px; padding:10px 12px; border-top:1px solid var(--stroke); flex-wrap:wrap; }
  .btn, .controls button, .chip, .seg button{
    appearance:none; border:1px solid var(--stroke); background:#0f1320; color:var(--ink);
    padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:600; text-decoration:none; display:inline-flex; align-items:center;
  }
  .btn:hover, .chip:hover, .seg button:hover, .controls button:hover{ border-color:var(--accent) }
  .chipbar{ display:flex; gap:8px; padding:12px 12px 0 12px; flex-wrap:wrap; }
  .chip{ border-radius:999px; padding:6px 10px }
  .seg{ display:inline-flex; gap:0; border:1px solid var(--stroke); border-radius:10px; overflow:hidden; }
  .seg button{ border:0; background:#0f1320; padding:6px 10px; }
  .seg button.active{ background:#141823; border-right:1px solid var(--stroke) }
  .seg button + button{ border-left:1px solid var(--stroke) }
  .hint{ opacity:.75; font-size:12px; margin-left:auto }
  .divider{ height:1px; background:var(--stroke); margin:16px 0 }
  .debug{ font-size:12px; opacity:.75; padding:8px 12px; word-break:break-all }
</style>
</head>
<body>
<div class="wrap">

  <header>
    <h1>Embedded YouTube + Multipage PDFs</h1>
    <nav class="controls" style="border:none;padding:0">
      <a class="btn" href="../">Home</a>
      <a class="btn" href="https://ctlamedica.com" target="_blank" rel="noopener">CTL Amedica</a>
    </nav>
  </header>

  <div class="grid">
    <!-- LEFT: YOUTUBE -->
    <section class="card" aria-label="Video">
      <header><h2>Product Teaser (loops)</h2></header>
      <div class="frame">
        <iframe id="yt" title="YouTube video"
          allow="autoplay; encrypted-media; picture-in-picture; web-share"
          allowfullscreen loading="lazy" referrerpolicy="strict-origin-when-cross-origin"></iframe>
      </div>
      <div class="controls" role="group" aria-label="Video controls">
        <button id="playBtn">Play</button>
        <button id="pauseBtn">Pause</button>
        <span class="hint">Loop via <code>loop=1&playlist=VIDEO_ID</code> (autoplay on, muted)</span>
      </div>
    </section>

    <!-- RIGHT: PDF -->
    <section class="card" aria-label="PDF">
      <header>
        <h2 id="docTitle">Document</h2>
        <div class="seg" aria-label="View mode">
          <button id="modeAuto"   class="active" title="Prefer PDF.js for reliability">Auto</button>
          <button id="modePdfjs"               title="Force PDF.js viewer">PDF.js</button>
          <button id="modeNative"              title="Force native browser viewer">Native</button>
        </div>
        <a id="openTab" class="btn" target="_blank" rel="noopener">Open in new tab</a>
        <span class="hint" id="modeHint">Auto (PDF.js preferred)</span>
      </header>

      <div id="chipbar" class="chipbar"></div>

      <div class="frame" style="aspect-ratio:auto; flex:1 1 auto;">
        <iframe id="pdfFrame" title="PDF" loading="lazy" referrerpolicy="no-referrer-when-downgrade"></iframe>
      </div>
      <div class="controls" role="group" aria-label="PDF page controls">
        <button id="prevBtn">◀ Prev page</button>
        <button id="nextBtn">Next page ▶</button>
        <span class="hint" id="pageLabel">page 1</span>
      </div>
      <div id="debug" class="debug"></div>
    </section>
  </div>

  <div class="divider" aria-hidden="true"></div>
  <section class="card" aria-label="Links">
    <header><h2>Quick Links</h2></header>
    <div class="controls">
      <a class="btn" href="../">Home</a>
      <a class="btn" href="https://ctlamedica.com" target="_blank" rel="noopener">CTL Amedica</a>
      <span class="hint">Edit DOCS & YouTube in the script.</span>
    </div>
  </section>
</div>

<script>
  // ========= CONFIG =========
  const YT_ID = "cLHOGWiA6YQ";

  // Candidate locations for your PDF.js viewer. Put your real path(s) here.
  // The script will pick the first one that exists; otherwise it will fall back to native PDF.
  const VIEWER_CANDIDATES = [
    "vendor/pdfjs/web/viewer.html",                // relative to this page (recommended project layout)
    "/qr-redirects/vendor/pdfjs/web/viewer.html"   // absolute to site root (if your repo root is /qr-redirects/)
  ];

  // PDFs expected to be in the SAME folder as this HTML file (names are case-sensitive).
  const DOCS = [
    { key:"klimt-stg",                      label:"KLIMT STG",                    path:"KLIMT-STG.pdf" },
    { key:"klimt-expansion-table-and-tips", label:"Klimt Expansion Table & Tips", path:"Klimt-Expansion-table-and-Tips.pdf" },
    { key:"klimt-expansion-table",          label:"Klimt Expansion Table",        path:"Klimt-Expansion-table.pdf" }
  ];
  const ALIASES = { "klimt-training":"klimt-stg", "klimt-stg-367003-0904":"klimt-stg" };
  const DEFAULT_KEY = "klimt-stg";
  // ==========================

  // --- YouTube ---
  (function initYouTube(){
    const yt = document.getElementById('yt');
    const origin = location.origin;
    const params = new URLSearchParams({
      autoplay:'1', mute:'1', controls:'1', modestbranding:'1', rel:'0',
      playsinline:'1', loop:'1', playlist:YT_ID, enablejsapi:'1', origin
    });
    yt.src = `https://www.youtube.com/embed/${YT_ID}?` + params.toString();
    const post = (func)=> yt.contentWindow.postMessage(JSON.stringify({event:'command', func}),'*');
    document.getElementById('playBtn').addEventListener('click', ()=>post('playVideo'));
    document.getElementById('pauseBtn').addEventListener('click',()=>post('pauseVideo'));
  })();

  // --- PDF tri-mode viewer with auto-detect + fallback ---
  const pdfFrame  = document.getElementById("pdfFrame");
  const pageLabel = document.getElementById("pageLabel");
  const docTitle  = document.getElementById("docTitle");
  const chipbar   = document.getElementById("chipbar");
  const debugOut  = document.getElementById("debug");
  const openTab   = document.getElementById("openTab");
  const modeHint  = document.getElementById("modeHint");

  const modeBtns  = {
    auto:   document.getElementById("modeAuto"),
    pdfjs:  document.getElementById("modePdfjs"),
    native: document.getElementById("modeNative")
  };

  const encodePath = p => p.split('/').map(encodeURIComponent).join('/');

  // Build chips
  DOCS.forEach(d=>{
    const a = document.createElement('a');
    a.className = 'chip';
    a.textContent = d.label;
    a.href = `#doc=${encodeURIComponent(d.key)}&page=1`;
    chipbar.appendChild(a);
  });

  const getHash = (name, fallback)=>{
    const params = new URLSearchParams(location.hash.slice(1));
    return params.get(name) ?? fallback;
  };

  let currentPage = 1;
  let currentDoc  = DEFAULT_KEY;
  let viewMode    = 'auto';   // 'auto' | 'pdfjs' | 'native'
  let viewerPath  = null;     // resolved viewer path or null if not found

  const resolveDoc = key => DOCS.find(d => d.key === key) || DOCS.find(d => d.key === DEFAULT_KEY);

  const buildNativeSrc = (path, page)=> `${encodePath(path)}#page=${page}&zoom=page-fit`;
  const buildPdfjsSrc  = (viewer, path, page)=> {
    const fileURL = new URL(path, location.href).toString(); // absolute (same-origin)
    return `${viewer}?file=${encodeURIComponent(fileURL)}#pagemode=none&zoom=page-fit&page=${page}`;
  };

  function updateModeButtons(){
    Object.entries(modeBtns).forEach(([k,btn])=>{
      btn.classList.toggle('active', k === viewMode || (viewMode==='auto' && k==='auto'));
    });
    modeHint.textContent = (viewMode==='native') ? 'Native mode'
                        : (viewMode==='pdfjs')  ? 'PDF.js mode'
                        : 'Auto (PDF.js preferred)';
  }

  function debug(msg){
    if (!debugOut) return;
    debugOut.innerHTML = msg;
  }

  async function headOk(url){
    try{
      const res = await fetch(url, { method:'HEAD', cache:'no-store' });
      return res.ok;
    }catch(e){ return false; }
  }

  async function resolveViewerPath(){
    // If already resolved, keep it.
    if (viewerPath) return viewerPath;
    for (const candidate of VIEWER_CANDIDATES){
      // Make it absolute for the HEAD check
      const abs = new URL(candidate, location.href).toString();
      if (await headOk(abs)) {
        viewerPath = candidate;
        return viewerPath;
      }
    }
    viewerPath = null; // none found
    return null;
  }

  async function loadPage(n){
    currentPage = Math.max(1, n);
    const doc   = resolveDoc(currentDoc);

    // Verify the PDF exists; if not, tell the user exactly what failed.
    const absPdf = new URL(doc.path, location.href).toString();
    const pdfExists = await headOk(absPdf);

    if (!pdfExists){
      const direct = encodePath(doc.path);
      debug(`❌ PDF not found: <code>${doc.path}</code><br>
             Tried: <a href="${absPdf}" target="_blank" rel="noopener">${absPdf}</a><br>
             Check filename & case, and that it’s in the same folder as this page.`);
      // Still point the “Open in new tab” to the direct (may 404) to help you test
      openTab.href = direct;
      pdfFrame.src = "about:blank";
      pageLabel.textContent = `page ${currentPage}`;
      docTitle.textContent  = doc.label;
      updateModeButtons();
      return;
    }

    // Decide mode
    let modeToUse = viewMode;
    if (viewMode === 'auto'){
      // Prefer PDF.js, but only if we can find the viewer
      const vp = await resolveViewerPath();
      modeToUse = vp ? 'pdfjs' : 'native';
    }

    let src, direct;
    direct = encodePath(doc.path);

    if (modeToUse === 'pdfjs'){
      const vp = await resolveViewerPath(); // should be non-null if we're here
      if (!vp){
        // Safety: fallback to native
        src = buildNativeSrc(doc.path, currentPage);
        modeToUse = 'native';
      } else {
        src = buildPdfjsSrc(vp, doc.path, currentPage);
      }
    } else {
      src = buildNativeSrc(doc.path, currentPage);
    }

    pdfFrame.src = src;
    openTab.href = (modeToUse === 'pdfjs') ? src : direct; // open the same thing you see
    openTab.download = ""; // let user save if desired
    pageLabel.textContent = `page ${currentPage}`;
    docTitle.textContent  = doc.label;

    // Debug panel: clickable links to the exact URLs being used
    const viewerResolved = viewerPath
      ? new URL(viewerPath, location.href).toString()
      : '(none found)';
    debug(`Mode: <b>${modeToUse}</b><br>
           Viewer: ${viewerPath ? `<a href="${viewerResolved}" target="_blank" rel="noopener">${viewerResolved}</a>` : '—'}<br>
           Iframe src: <a href="${src}" target="_blank" rel="noopener">${src}</a><br>
           Direct PDF: <a href="${absPdf}" target="_blank" rel="noopener">${absPdf}</a>`);

    updateModeButtons();
  }

  function applyFromHash(){
    const raw  = decodeURIComponent(getHash("doc", DEFAULT_KEY));
    const key  = ALIASES[raw] || raw;
    const page = parseInt(getHash("page", "1"), 10) || 1;
    currentDoc  = key;
    currentPage = Math.max(1, page);
    loadPage(currentPage);
  }

  // Wire paging & mode
  document.getElementById("prevBtn").addEventListener("click", ()=>loadPage(currentPage-1));
  document.getElementById("nextBtn").addEventListener("click", ()=>loadPage(currentPage+1));

  modeBtns.auto  .addEventListener('click', ()=>{ viewMode='auto';   loadPage(currentPage); });
  modeBtns.pdfjs .addEventListener('click', ()=>{ viewMode='pdfjs';  loadPage(currentPage); });
  modeBtns.native.addEventListener('click', ()=>{ viewMode='native'; loadPage(currentPage); });

  window.addEventListener('hashchange', applyFromHash);
  applyFromHash();
</script>
</body>
</html>
