<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>KLIMT • Reliable PDF Downloads</title>
<meta name="robots" content="noindex, nofollow" />
<style>
  :root{--bg:#0b0c10;--panel:#0d111a;--ink:#e8eaed;--muted:#9aa0a6;--stroke:#1e2330;--accent:#ffc81a}
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:15px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial}
  .wrap{min-height:100%;display:grid;grid-template-rows:auto 1fr auto;gap:16px;max-width:1100px;margin:0 auto;padding:16px}
  header{display:flex;align-items:center;justify-content:space-between;padding-bottom:8px;border-bottom:1px solid var(--stroke)}
  h1{margin:0;font-size:18px;font-weight:700}
  .card{background:var(--panel);border:1px solid var(--stroke);border-radius:14px;overflow:hidden}
  .head{display:flex;align-items:center;justify-content:space-between;padding:12px;border-bottom:1px solid var(--stroke)}
  .list{padding:12px;display:grid;gap:12px}
  .item{display:flex;align-items:center;gap:12px;flex-wrap:wrap;border:1px solid var(--stroke);border-radius:12px;padding:10px}
  .item h3{margin:0;font-size:14px}
  .btn{appearance:none;border:1px solid var(--stroke);background:linear-gradient(180deg,#0f1320,#0b0f1b);color:var(--ink);padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:600}
  .btn:hover{border-color:var(--accent)}
  .muted{color:var(--muted)}
  details.debug{padding:8px 12px;border-top:1px dashed var(--stroke);font-size:12px;color:var(--muted)}
  footer{display:flex;justify-content:flex-end;padding-top:8px;border-top:1px solid var(--stroke)}
</style>
</head>
<body>
<div class="wrap">
  <header><h1>KLIMT — PDF Downloads</h1></header>

  <section class="card">
    <div class="head"><h2 style="margin:0;font-size:14px">Documents</h2></div>
    <div id="docList" class="list" aria-live="polite"></div>
    <details class="debug"><summary>Debug</summary><div id="debugBody">Ready.</div></details>
  </section>

  <footer><span class="muted">Downloader tries Raw → Pages → Local, and only saves verified PDFs.</span></footer>
</div>

<script>
/* ===================== CONFIG: EDIT THIS BLOCK ONLY ===================== */
const DOCS = [
  {
    label: "KLIMT Overview",
    filename: "KLIMT-Overview.pdf",
    paths: {
      raw:   "https://raw.githubusercontent.com/ctlamedicamarketing/qr-redirects/main/r/CUSTOM-SpineWave/KLIMT/KLIMT-Overview.pdf",
      pages: "https://ctlamedicamarketing.github.io/qr-redirects/r/CUSTOM-SpineWave/KLIMT/KLIMT-Overview.pdf",
      local: "./KLIMT-Overview.pdf"
    }
  },
  {
    label: "KLIMT STG",
    filename: "KLIMT-STG.pdf",
    paths: {
      raw:   "https://raw.githubusercontent.com/ctlamedicamarketing/qr-redirects/main/r/CUSTOM-SpineWave/KLIMT/KLIMT-STG.pdf",
      pages: "https://ctlamedicamarketing.github.io/qr-redirects/r/CUSTOM-SpineWave/KLIMT/KLIMT-STG.pdf",
      local: "./KLIMT-STG.pdf"
    }
  },
  {
    label: "Klimt Expansion Table & Tips",
    filename: "Klimt-Expansion-table-and-Tips.pdf",
    paths: {
      raw:   "https://raw.githubusercontent.com/ctlamedicamarketing/qr-redirects/main/r/CUSTOM-SpineWave/KLIMT/Klimt-Expansion-table-and-Tips.pdf",
      pages: "https://ctlamedicamarketing.github.io/qr-redirects/r/CUSTOM-SpineWave/KLIMT/Klimt-Expansion-table-and-Tips.pdf",
      local: "./Klimt-Expansion-table-and-Tips.pdf"
    }
  },
  {
    label: "Klimt Expansion Table",
    filename: "Klimt-Expansion-table.pdf",
    paths: {
      raw:   "https://raw.githubusercontent.com/ctlamedicamarketing/qr-redirects/main/r/CUSTOM-SpineWave/KLIMT/Klimt-Expansion-table.pdf",
      pages: "https://ctlamedicamarketing.github.io/qr-redirects/r/CUSTOM-SpineWave/KLIMT/Klimt-Expansion-table.pdf",
      local: "./Klimt-Expansion-table.pdf"
    }
  }
];
/* =================== END CONFIG (no edits needed below) ================== */

// --- tiny helpers ---
async function tryHead(url){
  try { const r = await fetch(url, {method:'HEAD', cache:'no-store', mode:'cors'}); return r.ok ? r : null; }
  catch { return null; }
}
function urlCandidates(p){
  const c = [];
  if (p.raw)   c.push(p.raw);
  if (p.pages) c.push(p.pages);
  if (p.local){ try { c.push(new URL(p.local, location.href).toString()); } catch { c.push(p.local); } }
  return c;
}
function withBuster(u){ const x = new URL(u, location.href); x.searchParams.set('_v', Date.now()); return x.toString(); }

// verify a real PDF: MIME or %PDF- header + %%EOF trailer + size sanity
async function isRealPdf(res, blob){
  const size = blob.size;
  if (size < 1024) return {ok:false, why:`too small (${size} B)`};
  const ct = (res.headers.get('content-type')||'').toLowerCase();
  const ctPdf = ct.includes('application/pdf');
  const head = new Uint8Array(await blob.slice(0,5).arrayBuffer());
  const hasHeader = head[0]===0x25 && head[1]===0x50 && head[2]===0x44 && head[3]===0x46 && head[4]===0x2D; // %PDF-
  const tailText = await blob.slice(Math.max(0,size-1024), size).text();
  const hasEOF = /%%EOF\s*$/.test(tailText);
  return {ok:(ctPdf || hasHeader) && hasEOF, why:`ct=${ct||'unknown'} hdr=${hasHeader} eof=${hasEOF} size=${size}`};
}

// try candidates sequentially until a valid PDF is fetched
async function forceDownload(paths, suggestedName, btn){
  const original = btn.textContent; btn.textContent="Downloading…"; btn.disabled=true;
  const candidates = urlCandidates(paths);
  let lastUrl = null, lastErr = null;

  try{
    for (const base of candidates){
      lastUrl = base;
      try{
        if (!base.startsWith('http') || base.includes('github.io') || base.includes('raw.githubusercontent'))
          await tryHead(base); // not fatal if fails

        const url = withBuster(base);
        const res = await fetch(url, {mode:'cors', credentials:'omit', cache:'no-store'});
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const blob = await res.blob();

        const verdict = await isRealPdf(res, blob);
        if (!verdict.ok) { lastErr = new Error(`Not a PDF from ${base}: ${verdict.why}`); continue; }

        // filename: Content-Disposition > URL path > suggested
        const cd = res.headers.get('content-disposition');
        let filename = suggestedName;
        if (cd){
          const m = cd.match(/filename\*?=(?:UTF-8''|")?([^\";]+)\"?/i);
          if (m && m[1]) { try{ filename = decodeURIComponent(m[1]); } catch { filename = m[1]; } }
        } else {
          try{ filename = new URL(base).pathname.split('/').pop() || suggestedName; } catch{}
        }

        const a = document.createElement('a');
        const objectUrl = URL.createObjectURL(blob);
        a.href = objectUrl; a.download = filename;
        document.body.appendChild(a); a.click(); a.remove();
        URL.revokeObjectURL(objectUrl);

        btn.textContent = "Downloaded ✓";
        console.info(`[PDF] saved ${filename} from ${base} (${blob.size} B)`);
        return; // success
      }catch(e){ lastErr = e; console.warn('Attempt failed:', base, e); }
    }
    // all failed → open the last one for manual Save As…
    console.warn('All sources failed. Last error:', lastErr);
    window.open(lastUrl, '_blank', 'noopener');
    btn.textContent = "Opened in new tab";
  } finally {
    setTimeout(()=>{ btn.textContent = original; btn.disabled=false; }, 1800);
  }
}

// --- build UI ---
const els = { list: document.getElementById('docList'), debug: document.getElementById('debugBody') };

(async function populate(){
  for (const d of DOCS){
    const row = document.createElement('div'); row.className='item';
    const h = document.createElement('h3'); h.textContent = d.label;
    const b = document.createElement('button'); b.className='btn'; b.textContent='Download';
    b.addEventListener('click', ()=>forceDownload(d.paths, d.filename, b));
    row.append(h,b); els.list.appendChild(row);

    // Debug reachability (optional but handy)
    for (const [label,url] of [['Raw',d.paths.raw],['Pages',d.paths.pages],['Local',d.paths.local?new URL(d.paths.local,location.href).toString():null]]){
      if (!url) continue;
      let status='…'; try{ status = (await tryHead(url)) ? '✅' : '⚠️ (HEAD failed)'; }catch{ status='⚠️'; }
      const p=document.createElement('p'); p.innerHTML=`• <b>${d.label}</b> – ${label}: <a href="${url}" target="_blank" rel="noopener">${url}</a> ${status}`;
      els.debug.appendChild(p);
    }
  }
})();
</script>
</body>
</html>
